/* WARNING: THIS PROGRAM MAY FAIL TO WORK AS EXPECTED AND DO MORE THAN INTENDED.
   THIS PROGRAM COMES WITH NO WARRANTY, EXPRESSED OR IMPLIED.                 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void print_help(void)
{
	puts("* WARNING: THIS PROGRAM MAY FAIL TO WORK AS EXPECTED AND DO MORE THAN INTENDED.");
	puts("* THIS PROGRAM COMES WITH NO WARRANTY, EXPRESSED OR IMPLIED.");
	puts("");
	puts("Usage:");
	puts("STRIPBSS.EXE <EXEFILE.EXE> [<BSS_LOC_IN_EXE_IMAGE_AS_HEX>]");
	puts("");
	puts("Example:");
	puts("STRIPBSS.EXE WOLF3D.EXE 3559E");
	puts("");
	puts("Note: EXE filename *must* end with .EXE. The original EXE is renamed so it ends");
	puts("with .OLB, while a new EXE is generated using the original filename.");
	puts("");
	puts("In addition, the location of the BSS is optional *if* a file with the same");
	puts("name but the extension of .MAP is found (so WOLF3D.MAP in the example above),");
	puts("generated by the Borland C++ 2.0/3.0/3.1 linker and having a mention");
	puts("of the BSS. The MAP file should have these columns:");
	puts("");
	puts(" Start  Stop   Length Name               Class");
	puts("");
	puts("The corresponding line in the MAP file should look like this, more-or-less:");
	puts("");
	puts(" 23CA2H 241E7H 00546H _BSS               BSS");
}

int main(int argc, char **argv)
{
	size_t filenamelen;
	unsigned long exestart;
	unsigned long bssloc, bssstop, bsslen;
	long inputfsize, inputeffectivefsize, outputfssize;
	char *renfilename;
	FILE *finput, *foutput;
	unsigned char buffer[1024];
	/* WARNING: Assumes tight packing,
	   plus Little-Endian byte ordering (and possibly more).
	   Taken off: http://www.delorie.com/djgpp/doc/exe/   */
	struct {
		unsigned short signature; /* == 0x5a4D */
		unsigned short bytes_in_last_block;
		unsigned short blocks_in_file;
		unsigned short num_relocs;
		unsigned short header_paragraphs;
		unsigned short min_extra_paragraphs;
		/* Some more fields come here, but we just write them as-is */
	} exeHeaderPartial;

	if ((argc != 2) && (argc != 3))
	{
		print_help();
		return 0;
	}
	filenamelen = strlen(argv[1]);
	if ((filenamelen < 4) || stricmp(argv[1]+filenamelen-4, ".EXE"))
	{
		puts("Bad argument for STRIPBSS: First argument should be a filename ending with .EXE");
		return 1;
	}

	finput = fopen(argv[1], "rb");
	if (!finput)
	{
		printf("ERROR: Can't open file %s for reading\n", argv[1]);
		return 6;
	}
	fseek(finput, 0L, SEEK_END);
	inputfsize = ftell(finput);
	fseek(finput, 0L, SEEK_SET);

	if (inputfsize < sizeof(exeHeaderPartial))
	{
		fclose(finput);
		printf("ERROR: Input file %s isn't a compatible 16-bit DOS EXE file!\n", renfilename);
		return 7;
	}

	fread(&exeHeaderPartial, sizeof(exeHeaderPartial), 1, finput);
	fclose(finput);

	renfilename = (char *)malloc(filenamelen+1);
	if (!renfilename)
	{
		puts("FATAL ERROR: Can't allocate storage for renamed file name");
		return 2;
	}
	memcpy(renfilename, argv[1], filenamelen-4);

	if (argc == 2)
	{
		// HACK: Use renfilename for .MAP file if required
		strcpy(renfilename+(filenamelen-4), ".MAP");
		finput = fopen(renfilename, "rb");
		if (!finput)
		{
			free(renfilename);
			print_help();
			return 0;
		}
		while (fgets(buffer, sizeof(buffer), finput))
		{
			if (strstr(buffer, "_BSS               BSS") != buffer+strlen(" AAAAAH BBBBBH CCCCCH "))
				continue;
			if (sscanf(buffer, " %05lXH %05lXH %05lXH", &bssloc, &bssstop, &bsslen) != 3)
				continue;
			printf("%s\n", buffer);
			// HACK - Means match is found
			printf("Read from MAP file %lXH %lXH %lXH\n", bssloc, bssstop, bsslen);
			fclose(finput);
			finput = NULL;
			break;
		}
		if (finput) // HACK
		{
			printf("Cannot read proper BSS line from file %s\n", renfilename);
			free(renfilename);
			return 3;
		}
	}
	else if (sscanf(argv[2], "%lX", &bssloc) != 1)
	{
		puts("Bad argument for STRIPBSS: Second argument's format should be");
		puts("an unsigned hexadecimal value like 3559E.");
		return 4;
	}


	strcpy(renfilename+(filenamelen-4), ".OLB");
	if (rename(argv[1], renfilename) != 0)
	{
		free(renfilename);
		printf("ERROR: Can't rename file %s to %s\n", argv[1], renfilename);
		return 5;
	}

	finput = fopen(renfilename, "rb");
	if (!finput)
	{
		free(renfilename);
		printf("ERROR: Can't open renamed file %s for reading\n", renfilename);
		return 6;
	}
	// We have already read the EXE's header (before renaming file) so skip it
	fseek(finput, sizeof(exeHeaderPartial), SEEK_SET);

	inputeffectivefsize = 0x200L * exeHeaderPartial.blocks_in_file;
	if (exeHeaderPartial.bytes_in_last_block)
	{
		inputeffectivefsize -= 0x200L;
		inputeffectivefsize += exeHeaderPartial.bytes_in_last_block;
	}

	if ((inputfsize < inputeffectivefsize) || (exeHeaderPartial.signature != 0x5A4D))
	{
		free(renfilename);
		fclose(finput);
		printf("ERROR: Input file %s isn't a compatible 16-bit DOS EXE file!\n", renfilename);
		return 8;
	}

	exestart = ((unsigned long)exeHeaderPartial.header_paragraphs)*0x10L;
	outputfssize = bssloc+exestart;

	if (outputfssize > inputeffectivefsize)
	{
		free(renfilename);
		fclose(finput);
		printf("ERROR: Input BSS location is wrong for the given EXE!\n", renfilename);
		return 9;
	}

	printf("Output EXE file size (hexadecimal): %lX\n", outputfssize);

	/* Now modify the header */
	exeHeaderPartial.min_extra_paragraphs = (inputeffectivefsize-outputfssize)/0x10L;

	if ((inputeffectivefsize-outputfssize)%0x10L)
		++exeHeaderPartial.min_extra_paragraphs;

	exeHeaderPartial.bytes_in_last_block = outputfssize%0x200;
	exeHeaderPartial.blocks_in_file = outputfssize/0x200;

	if (!exeHeaderPartial.bytes_in_last_block)
		exeHeaderPartial.bytes_in_last_block = 0x200;
	else
		++exeHeaderPartial.blocks_in_file;

	/* Finally open file for writing (should better be done late) */
	foutput = fopen(argv[1], "wb");
	if (!foutput)
	{
		free(renfilename);
		fclose(finput);
		printf("ERROR: Can't open new file %s for writing (old file is renamed %s)\n", argv[1], renfilename);
		return 10;
	}


	/* Write this modified part of the header */
	fwrite(&exeHeaderPartial, sizeof(exeHeaderPartial), 1, foutput);

	outputfssize -= sizeof(exeHeaderPartial);
	/* Copy 1024 bytes long chunks from one file to the other
	 * (including what's left out of the EXE header) - 16-bit compatible...
	 */
	while (outputfssize > sizeof(buffer))
	{
		fread(buffer, sizeof(buffer), 1, finput);
		fwrite(buffer, sizeof(buffer), 1, foutput);
		outputfssize -= sizeof(buffer);
	}
	fread(buffer, outputfssize, 1, finput);
	fwrite(buffer, outputfssize, 1, foutput);


	free(renfilename);
	fclose(finput);
	fclose(foutput);
	return 0;
}
